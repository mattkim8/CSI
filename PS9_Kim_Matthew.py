# Problem Set 9# Name: Kim,Matthew# Collaborators: last name1, first name1; last name2, first name2; etc.class Fraction(object):    """The fraction class to denote rational numbers (fractions)."""        def __init__(self, numerator=0, denominator=1):        """The constructor method that initializes the instance with the        given data at the time of object instantiation.        The default values for the numerator and denominator are 0 and 1,        respectively.        """        a, b = verify(numerator, denominator)        self.num = a        self.denom = b        self.reduce_frac()    def reduce_frac(self):        """Reduce the fraction to its lowest terms."""        factor = gcd(abs(self.num), self.denom)        self.num = self.num / factor        self.denom = self.denom / factor    def __str__(self):        """Return the pretty string representation of the given instance."""        if self.denom == 1:            return str(self.num)        return str(self.num) + '/' + str(self.denom)    def __add__(self, other):        """Return the fraction resulted from adding two fractions together        (this is the special method that is used when the + operator is used        with two instances of this class.        """        a = self        b = other        new_num = (a.num*b.denom) + (b.num * a.denom)        new_denom = a.denom * b.denom        return Fraction(new_num,new_denom)                        def __neg__(self):        """Return a new fraction that is the result of negating the given        instance (fraction) (its sign is the opposite sign of self).        """        return Fraction(self.num * -1, self.denom)            def __sub__(self, other):        """Substract the other instance of the Fraction class from the current        instance of that class and return the result. This method will be        invoked when we use the - operator with two instances of the Fraction        class. Can you use the two previous methods to complete this?        """        a = self        b = other        new_num = (a.num*b.denom) - (b.num * a.denom)        new_denom = a.denom * b.denom        return Fraction(new_num,new_denom)            def __mul__(self, other):        """Multiply the given Fraction instance by the other Fraction        instance and return the result (this magic method is invoked when the        * operator is used along with two instances of this class as its        operands.        """        return Fraction(self.num * other.num, self.denom*other.denom)            def reciprocal(self):        """Return d/n if the fraction is n/d. If n is equal to zero, raise        a ZeroDivisionError with an appropriate message sent to the client.        """        return Fraction(self.denom,self.num)                    def __div__(self, other):        """Divide the given instance of the Fraction class by the other        instance of that class and return the result (this method will be        invoked when the / operator is used). Do you want to use the reciprocal        method and perhaps another method that you've defined already?        """        return Fraction(self.num * other.denom, self.denom*other.num)            def __eq__(self, other):        """Determine if the value of the current instance of the class is        equal to the value of the other instance of this class (using the ==        operator invokes this method). If it is, return True; otherwise,        return False.        """        a = Fraction(self.num,self.denom)        b = Fraction(other.num,other.denom)        if a.num == b.num and a.denom == b.denom:            return True        else:            return False            def __gt__(self, other):        """If the fraction represented by self is greater than the fraction        denoted by other, return True; otherwise, return False.        """        a = Fraction(self.num,self.denom)        b = Fraction(other.num,other.denom)        return float(a) > float(b)                    def __ge__(self, other):        """self greater than or equal to other (Can you use two other methods        to complete this?).        """        if self > other or self == other:            return True        return False            def __lt__(self, other):        """self less than other (should be trivial using the other methods        you've defined).        """        return float(self) < float(other)            def __le__(self, other):        """self less than or equal to other (again, should be trivial)."""        if self < other or self == other:            return True        return False            def __float__(self):        """Return the float representation of the given Fraction object        For example, Fraction(2, 4) is 0.5 and Fraction(1, 3) is 0.33333...33.        """        return self.num/float(self.denom)        def verify(numerator, denominator):    if not (isinstance(numerator, int) and isinstance(denominator, int)):        raise TypeError('The numerator and denominator must be integers!')    if denominator == 0:        raise ZeroDivisionError('The denominator cannot be zero!')    elif denominator < 0:        # We always want the denominator to be positive.        denominator = -denominator        numerator = -numerator    return numerator, denominatordef gcd(a, b):    """Euclid's algorithm to determine the gcd of two given integers."""    if b == 0:        return a    return gcd(b, a%b)# Please don't change anything in the following function defintion.def main():    """This function is to test your methods for Fraction objects."""    f1 = Fraction(12, 16)    f2 = Fraction(-1, 2)    print 'f1 =', f1    print 'f2 =', f2    print 'f1 + f2 =', f1 + f2    print '-f2 =', -f2    print 'f1 - f2 =', f1 - f2    print 'f1 * f2 =', f1 * f2    print '1 / f1 =', f1.reciprocal()    print 'f1 / f2 =', f1 / f2    print '2/4 is equal to 1/2?', Fraction(2, 4) == Fraction(1, 2)    print '0 is equal to 0?', Fraction(0, 4) == Fraction(0, 2)    print '2/4 is equal to 1/4?', Fraction(2, 4) == Fraction(1, 4)    print '2/4 is greater than 1/4?', Fraction(2, 4) > Fraction(1, 4)    print '1/3 is greater than 2/3?', Fraction(1, 3) > Fraction(2, 3)    print '2/4 is greater than or equal to 1/4?', Fraction(2, 4) >= Fraction(1, 4)    print '-2/4 is greater than or equal to 1/4?', Fraction(-2, 4) >= Fraction(1, 4)    print '2/4 is less than 1/4?', Fraction(2, 4) < Fraction(1, 4)    print '1/3 is less than 2/3?', Fraction(1, 3) < Fraction(2, 3)    print '2/4 is less than or equal to 1/4?', Fraction(2, 4) <= Fraction(1, 4)    print '-2/4 is less than or equal to 1/4?', Fraction(-2, 4) <= Fraction(1, 4)    print '2/4 =', float(Fraction(2, 4))    print '-1/3 =', float(Fraction(-1, 3))    f3 = Fraction(0, 2)    try:        print 'Testing the reciprocal method on Fraction instances...'        f4 = f3.reciprocal()    except ZeroDivisionError:        print 'Great job! Your reciprocal method is working perfectly!'    else:        print ('Please check your reciprocal method! '               'It is not working as expected!')# Please don't remove this function call here.    main()